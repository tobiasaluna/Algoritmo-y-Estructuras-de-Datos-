A continuación se presenta una tabla comparativa de los algoritmos de ordenamiento discutidos, 
incluyendo su complejidad en el mejor caso, caso promedio y peor caso, así como su uso de espacio y si son estables o no.

<img width="624" height="422" alt="image" src="https://github.com/user-attachments/assets/fc7be416-3c5c-4476-9d33-af77cbf272f0" />

Casos de uso recomendados
- Burbuja: Útil para listas pequeñas o casi ordenadas.
- Inserción: Eficiente para listas pequeñas o casi ordenadas.
- Selección: Útil cuando la memoria es limitada.
- Shell Sort: Bueno para listas medianas.
- Merge Sort: Ideal para listas grandes y datos externos.
- QuickSort: Generalmente rápido para listas grandes, pero cuidado con el peor caso.
- Heap Sort: Útil cuando se requiere un ordenamiento in-place con complejidad garantizada.
- Optimizado QuickSort: Recomendado para la mayoría de los casos prácticos debido a su eficiencia y adaptabilidad.
